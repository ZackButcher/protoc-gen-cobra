// Code generated by tetratelabs/protoc-gen-cobra.
// source: nested.proto
// DO NOT EDIT!

package pb

import (
	tls "crypto/tls"
	x509 "crypto/x509"
	fmt "fmt"
	ioutil "io/ioutil"
	log "log"
	net "net"
	os "os"
	filepath "path/filepath"
	time "time"

	proto "github.com/golang/protobuf/proto"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	iocodec "github.com/tetratelabs/protoc-gen-cobra/iocodec"
	context "golang.org/x/net/context"
	oauth2 "golang.org/x/oauth2"
	grpc "google.golang.org/grpc"
	credentials "google.golang.org/grpc/credentials"
	oauth "google.golang.org/grpc/credentials/oauth"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

var _DefaultNestedMessagesClientCommandConfig = _NewNestedMessagesClientCommandConfig()

type _NestedMessagesClientCommandConfig struct {
	ServerAddr         string
	RequestFile        string
	PrintSampleRequest bool
	ResponseFormat     string
	Timeout            time.Duration
	TLS                bool
	ServerName         string
	InsecureSkipVerify bool
	CACertFile         string
	CertFile           string
	KeyFile            string
	AuthToken          string
	AuthTokenType      string
	JWTKey             string
	JWTKeyFile         string
}

func _NewNestedMessagesClientCommandConfig() *_NestedMessagesClientCommandConfig {
	c := &_NestedMessagesClientCommandConfig{
		ServerAddr:     "localhost:8080",
		ResponseFormat: "json",
		Timeout:        10 * time.Second,
		AuthTokenType:  "Bearer",
	}
	return c
}

func (o *_NestedMessagesClientCommandConfig) AddFlags(fs *pflag.FlagSet) {
	fs.StringVarP(&o.ServerAddr, "server-addr", "s", o.ServerAddr, "server address in form of host:port")
	fs.StringVarP(&o.RequestFile, "request-file", "f", o.RequestFile, "client request file (must be json, yaml, or xml); use \"-\" for stdin + json")
	fs.BoolVarP(&o.PrintSampleRequest, "print-sample-request", "p", o.PrintSampleRequest, "print sample request file and exit")
	fs.StringVarP(&o.ResponseFormat, "response-format", "o", o.ResponseFormat, "response format (json, prettyjson, yaml, or xml)")
	fs.DurationVar(&o.Timeout, "timeout", o.Timeout, "client connection timeout")
	fs.BoolVar(&o.TLS, "tls", o.TLS, "enable tls")
	fs.StringVar(&o.ServerName, "tls-server-name", o.ServerName, "tls server name override")
	fs.BoolVar(&o.InsecureSkipVerify, "tls-insecure-skip-verify", o.InsecureSkipVerify, "INSECURE: skip tls checks")
	fs.StringVar(&o.CACertFile, "tls-ca-cert-file", o.CACertFile, "ca certificate file")
	fs.StringVar(&o.CertFile, "tls-cert-file", o.CertFile, "client certificate file")
	fs.StringVar(&o.KeyFile, "tls-key-file", o.KeyFile, "client key file")
	fs.StringVar(&o.AuthToken, "auth-token", o.AuthToken, "authorization token")
	fs.StringVar(&o.AuthTokenType, "auth-token-type", o.AuthTokenType, "authorization token type")
	fs.StringVar(&o.JWTKey, "jwt-key", o.JWTKey, "jwt key")
	fs.StringVar(&o.JWTKeyFile, "jwt-key-file", o.JWTKeyFile, "jwt key file")
}

var NestedMessagesClientCommand = &cobra.Command{
	Use: "nestedmessages",
}

func _DialNestedMessages() (*grpc.ClientConn, NestedMessagesClient, error) {
	cfg := _DefaultNestedMessagesClientCommandConfig
	opts := []grpc.DialOption{
		grpc.WithBlock(),
		grpc.WithTimeout(cfg.Timeout),
	}
	if cfg.TLS {
		tlsConfig := &tls.Config{}
		if cfg.InsecureSkipVerify {
			tlsConfig.InsecureSkipVerify = true
		}
		if cfg.CACertFile != "" {
			cacert, err := ioutil.ReadFile(cfg.CACertFile)
			if err != nil {
				return nil, nil, fmt.Errorf("ca cert: %v", err)
			}
			certpool := x509.NewCertPool()
			certpool.AppendCertsFromPEM(cacert)
			tlsConfig.RootCAs = certpool
		}
		if cfg.CertFile != "" {
			if cfg.KeyFile == "" {
				return nil, nil, fmt.Errorf("missing key file")
			}
			pair, err := tls.LoadX509KeyPair(cfg.CertFile, cfg.KeyFile)
			if err != nil {
				return nil, nil, fmt.Errorf("cert/key: %v", err)
			}
			tlsConfig.Certificates = []tls.Certificate{pair}
		}
		if cfg.ServerName != "" {
			tlsConfig.ServerName = cfg.ServerName
		} else {
			addr, _, _ := net.SplitHostPort(cfg.ServerAddr)
			tlsConfig.ServerName = addr
		}
		//tlsConfig.BuildNameToCertificate()
		cred := credentials.NewTLS(tlsConfig)
		opts = append(opts, grpc.WithTransportCredentials(cred))
	} else {
		opts = append(opts, grpc.WithInsecure())
	}
	if cfg.AuthToken != "" {
		cred := oauth.NewOauthAccess(&oauth2.Token{
			AccessToken: cfg.AuthToken,
			TokenType:   cfg.AuthTokenType,
		})
		opts = append(opts, grpc.WithPerRPCCredentials(cred))
	}
	if cfg.JWTKey != "" {
		cred, err := oauth.NewJWTAccessFromKey([]byte(cfg.JWTKey))
		if err != nil {
			return nil, nil, fmt.Errorf("jwt key: %v", err)
		}
		opts = append(opts, grpc.WithPerRPCCredentials(cred))
	}
	if cfg.JWTKeyFile != "" {
		cred, err := oauth.NewJWTAccessFromFile(cfg.JWTKeyFile)
		if err != nil {
			return nil, nil, fmt.Errorf("jwt key file: %v", err)
		}
		opts = append(opts, grpc.WithPerRPCCredentials(cred))
	}
	conn, err := grpc.Dial(cfg.ServerAddr, opts...)
	if err != nil {
		return nil, nil, err
	}
	return conn, NewNestedMessagesClient(conn), nil
}

type _NestedMessagesRoundTripFunc func(cli NestedMessagesClient, in iocodec.Decoder, out iocodec.Encoder) error

func _NestedMessagesRoundTrip(sample interface{}, fn _NestedMessagesRoundTripFunc) error {
	cfg := _DefaultNestedMessagesClientCommandConfig
	var em iocodec.EncoderMaker
	var ok bool
	if cfg.ResponseFormat == "" {
		em = iocodec.DefaultEncoders["json"]
	} else {
		em, ok = iocodec.DefaultEncoders[cfg.ResponseFormat]
		if !ok {
			return fmt.Errorf("invalid response format: %q", cfg.ResponseFormat)
		}
	}
	if cfg.PrintSampleRequest {
		return em.NewEncoder(os.Stdout).Encode(sample)
	}
	var d iocodec.Decoder
	if cfg.RequestFile == "" || cfg.RequestFile == "-" {
		d = iocodec.DefaultDecoders["json"].NewDecoder(os.Stdin)
	} else {
		f, err := os.Open(cfg.RequestFile)
		if err != nil {
			return fmt.Errorf("request file: %v", err)
		}
		defer f.Close()
		ext := filepath.Ext(cfg.RequestFile)
		if len(ext) > 0 && ext[0] == '.' {
			ext = ext[1:]
		}
		dm, ok := iocodec.DefaultDecoders[ext]
		if !ok {
			return fmt.Errorf("invalid request file format: %q", ext)
		}
		d = dm.NewDecoder(f)
	}
	conn, client, err := _DialNestedMessages()
	if err != nil {
		return err
	}
	defer conn.Close()
	return fn(client, d, em.NewEncoder(os.Stdout))
}

// searching for NestedRequest
//   comparing against TopLevelNestedType
//     searching for NestedRequest
// * comparing against NestedRequest inserting into cache:
// map[NestedRequest:{0xc000116e10 true false}]
// searching for type '.pb.NestedRequest.InnerNestedType' with ttype: InnerNestedType
// searching for InnerNestedType
//   comparing against TopLevelNestedType
//     searching for InnerNestedType
//   comparing against NestedRequest
//     searching for InnerNestedType
//     * comparing against InnerNestedType inserting into cache:
// map[InnerNestedType:{0xc000116f00 true true} NestedRequest:{0xc000116e10 true false}]
// generating request initialization for InnerNestedType
// generating initialization for InnerNestedType with prefix "" which has 1 fields
// found non-message field "value"
// computed "&InnerNestedType{}"

// searching for type '.pb.TopLevelNestedType' with ttype: TopLevelNestedType
// searching for TopLevelNestedType
// * comparing against TopLevelNestedType inserting into cache:
// map[InnerNestedType:{0xc000116f00 true true} NestedRequest:{0xc000116e10 true false} TopLevelNestedType:{0xc000116d20 true false}]
// generating request initialization for TopLevelNestedType
// generating initialization for TopLevelNestedType with prefix "" which has 1 fields
// found non-message field "value"
// computed "&TopLevelNestedType{}"

// generating request initialization for NestedRequest
// searching for InnerNestedType
// * found InnerNestedTypein cache map[InnerNestedType:{0xc000116f00 true true} NestedRequest:{0xc000116e10 true false} TopLevelNestedType:{0xc000116d20 true false}]
// searching for TopLevelNestedType
// * found TopLevelNestedTypein cache map[InnerNestedType:{0xc000116f00 true true} NestedRequest:{0xc000116e10 true false} TopLevelNestedType:{0xc000116d20 true false}]
// generating initialization for NestedRequest with prefix "" which has 2 fields
// searching for type ".pb.NestedRequest.InnerNestedType" with ttype "InnerNestedType" for field "inner"
// found, recursing with "InnerNestedType"
// generating initialization for InnerNestedType with prefix "NestedRequest_" which has 1 fields
// found non-message field "value"
// computed "&NestedRequest_InnerNestedType{}"
// found field "Inner" which we'll initialize with "&NestedRequest_InnerNestedType{}"
// searching for type ".pb.TopLevelNestedType" with ttype "TopLevelNestedType" for field "top_level"
// found, recursing with "TopLevelNestedType"
// generating initialization for TopLevelNestedType with prefix "" which has 1 fields
// found non-message field "value"
// computed "&TopLevelNestedType{}"
// found field "TopLevel" which we'll initialize with "&TopLevelNestedType{}"
// computed "&NestedRequest{\nTopLevel: &TopLevelNestedType{},\nInner: &NestedRequest_InnerNestedType{},\n}"

func _NestedMessagesGetClientCommand() *cobra.Command {
	reqArgs := &NestedRequest{
		TopLevel: &TopLevelNestedType{},
		Inner:    &NestedRequest_InnerNestedType{},
	}

	cmd := &cobra.Command{
		Use:  "get",
		Long: "Get client\n\nYou can use environment variables with the same name of the command flags.\nAll caps and s/-/_, e.g. SERVER_ADDR.",
		Example: `
Save a sample request to a file (or refer to your protobuf descriptor to create one):
	get -p > req.json

Submit request using file:
	get -f req.json

Authenticate using the Authorization header (requires transport security):
	export AUTH_TOKEN=your_access_token
	export SERVER_ADDR=api.example.com:443
	echo '{json}' | get --tls`,
		Run: func(cmd *cobra.Command, args []string) {
			var v NestedRequest
			err := _NestedMessagesRoundTrip(v, func(cli NestedMessagesClient, in iocodec.Decoder, out iocodec.Encoder) error {

				err := in.Decode(&v)
				if err != nil {
					return err
				}

				proto.Merge(&v, reqArgs)
				resp, err := cli.Get(context.Background(), &v)

				if err != nil {
					return err
				}

				return out.Encode(resp)

			})
			if err != nil {
				log.Fatal(err)
			}
		},
	}

	cmd.PersistentFlags().StringVar(&reqArgs.Inner.Value, "inner-value", "", "get-comment-from-proto")
	cmd.PersistentFlags().StringVar(&reqArgs.TopLevel.Value, "toplevel-value", "", "get-comment-from-proto")

	return cmd
}

func init() {
	cmd := _NestedMessagesGetClientCommand()
	NestedMessagesClientCommand.AddCommand(cmd)
	_DefaultNestedMessagesClientCommandConfig.AddFlags(cmd.Flags())
}

// searching for DeeplyNested
//   comparing against TopLevelNestedType
//     searching for DeeplyNested
//   comparing against NestedRequest
//     searching for DeeplyNested
//       comparing against InnerNestedType
//         searching for DeeplyNested
//   comparing against NestedResponse
//     searching for DeeplyNested
// * comparing against DeeplyNested inserting into cache:
// map[DeeplyNested:{0xc0001170e0 true false}]
// searching for type '.pb.DeeplyNested.DeeplyNestedOuter' with ttype: DeeplyNestedOuter
// searching for DeeplyNestedOuter
//   comparing against TopLevelNestedType
//     searching for DeeplyNestedOuter
//   comparing against NestedRequest
//     searching for DeeplyNestedOuter
//       comparing against InnerNestedType
//         searching for DeeplyNestedOuter
//   comparing against NestedResponse
//     searching for DeeplyNestedOuter
//   comparing against DeeplyNested
//     searching for DeeplyNestedOuter
//     * comparing against DeeplyNestedOuter inserting into cache:
// map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedOuter:{0xc0001171d0 true true}]
// searching for type '.pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner' with ttype: DeeplyNestedInner
// searching for DeeplyNestedInner
//   comparing against TopLevelNestedType
//     searching for DeeplyNestedInner
//   comparing against NestedRequest
//     searching for DeeplyNestedInner
//       comparing against InnerNestedType
//         searching for DeeplyNestedInner
//   comparing against NestedResponse
//     searching for DeeplyNestedInner
//   comparing against DeeplyNested
//     searching for DeeplyNestedInner
//       comparing against DeeplyNestedOuter
//         searching for DeeplyNestedInner
//         * comparing against DeeplyNestedInner inserting into cache:
// map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// searching for type '.pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner.DeeplyNestedInnermost' with ttype: DeeplyNestedInnermost
// searching for DeeplyNestedInnermost
//   comparing against TopLevelNestedType
//     searching for DeeplyNestedInnermost
//   comparing against NestedRequest
//     searching for DeeplyNestedInnermost
//       comparing against InnerNestedType
//         searching for DeeplyNestedInnermost
//   comparing against NestedResponse
//     searching for DeeplyNestedInnermost
//   comparing against DeeplyNested
//     searching for DeeplyNestedInnermost
//       comparing against DeeplyNestedOuter
//         searching for DeeplyNestedInnermost
//           comparing against DeeplyNestedInner
//             searching for DeeplyNestedInnermost
//             * comparing against DeeplyNestedInnermost inserting into cache:
// map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// generating request initialization for DeeplyNestedInnermost
// generating initialization for DeeplyNestedInnermost with prefix "" which has 1 fields
// found non-message field "l3"
// computed "&DeeplyNestedInnermost{}"

// generating request initialization for DeeplyNestedInner
// searching for DeeplyNestedInnermost
// * found DeeplyNestedInnermostin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// generating initialization for DeeplyNestedInner with prefix "" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner.DeeplyNestedInnermost" with ttype "DeeplyNestedInnermost" for field "l2"
// found, recursing with "DeeplyNestedInnermost"
// generating initialization for DeeplyNestedInnermost with prefix "DeeplyNestedInner_" which has 1 fields
// found non-message field "l3"
// computed "&DeeplyNestedInner_DeeplyNestedInnermost{}"
// found field "L2" which we'll initialize with "&DeeplyNestedInner_DeeplyNestedInnermost{}"
// computed "&DeeplyNestedInner{\nL2: &DeeplyNestedInner_DeeplyNestedInnermost{},\n}"

// generating request initialization for DeeplyNestedOuter
// searching for DeeplyNestedInner
// * found DeeplyNestedInnerin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// searching for DeeplyNestedInnermost
// * found DeeplyNestedInnermostin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// generating initialization for DeeplyNestedOuter with prefix "" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner" with ttype "DeeplyNestedInner" for field "l1"
// found, recursing with "DeeplyNestedInner"
// generating initialization for DeeplyNestedInner with prefix "DeeplyNestedOuter_" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner.DeeplyNestedInnermost" with ttype "DeeplyNestedInnermost" for field "l2"
// found, recursing with "DeeplyNestedInnermost"
// generating initialization for DeeplyNestedInnermost with prefix "DeeplyNestedOuter_DeeplyNestedInner_" which has 1 fields
// found non-message field "l3"
// computed "&DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{}"
// found field "L2" which we'll initialize with "&DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{}"
// computed "&DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n}"
// found field "L1" which we'll initialize with "&DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n}"
// computed "&DeeplyNestedOuter{\nL1: &DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n},\n}"

// generating request initialization for DeeplyNested
// searching for DeeplyNestedOuter
// * found DeeplyNestedOuterin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// searching for DeeplyNestedInner
// * found DeeplyNestedInnerin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// searching for DeeplyNestedInnermost
// * found DeeplyNestedInnermostin cache map[DeeplyNested:{0xc0001170e0 true false} DeeplyNestedInner:{0xc0001172c0 true true} DeeplyNestedInnermost:{0xc0001173b0 true true} DeeplyNestedOuter:{0xc0001171d0 true true}]
// generating initialization for DeeplyNested with prefix "" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter" with ttype "DeeplyNestedOuter" for field "l0"
// found, recursing with "DeeplyNestedOuter"
// generating initialization for DeeplyNestedOuter with prefix "DeeplyNested_" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner" with ttype "DeeplyNestedInner" for field "l1"
// found, recursing with "DeeplyNestedInner"
// generating initialization for DeeplyNestedInner with prefix "DeeplyNested_DeeplyNestedOuter_" which has 1 fields
// searching for type ".pb.DeeplyNested.DeeplyNestedOuter.DeeplyNestedInner.DeeplyNestedInnermost" with ttype "DeeplyNestedInnermost" for field "l2"
// found, recursing with "DeeplyNestedInnermost"
// generating initialization for DeeplyNestedInnermost with prefix "DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_" which has 1 fields
// found non-message field "l3"
// computed "&DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{}"
// found field "L2" which we'll initialize with "&DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{}"
// computed "&DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n}"
// found field "L1" which we'll initialize with "&DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n}"
// computed "&DeeplyNested_DeeplyNestedOuter{\nL1: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n},\n}"
// found field "L0" which we'll initialize with "&DeeplyNested_DeeplyNestedOuter{\nL1: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n},\n}"
// computed "&DeeplyNested{\nL0: &DeeplyNested_DeeplyNestedOuter{\nL1: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{\nL2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},\n},\n},\n}"

func _NestedMessagesGetDeeplyNestedClientCommand() *cobra.Command {
	reqArgs := &DeeplyNested{
		L0: &DeeplyNested_DeeplyNestedOuter{
			L1: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner{
				L2: &DeeplyNested_DeeplyNestedOuter_DeeplyNestedInner_DeeplyNestedInnermost{},
			},
		},
	}

	cmd := &cobra.Command{
		Use:  "getdeeplynested",
		Long: "GetDeeplyNested client\n\nYou can use environment variables with the same name of the command flags.\nAll caps and s/-/_, e.g. SERVER_ADDR.",
		Example: `
Save a sample request to a file (or refer to your protobuf descriptor to create one):
	getdeeplynested -p > req.json

Submit request using file:
	getdeeplynested -f req.json

Authenticate using the Authorization header (requires transport security):
	export AUTH_TOKEN=your_access_token
	export SERVER_ADDR=api.example.com:443
	echo '{json}' | getdeeplynested --tls`,
		Run: func(cmd *cobra.Command, args []string) {
			var v DeeplyNested
			err := _NestedMessagesRoundTrip(v, func(cli NestedMessagesClient, in iocodec.Decoder, out iocodec.Encoder) error {

				err := in.Decode(&v)
				if err != nil {
					return err
				}

				proto.Merge(&v, reqArgs)
				resp, err := cli.GetDeeplyNested(context.Background(), &v)

				if err != nil {
					return err
				}

				return out.Encode(resp)

			})
			if err != nil {
				log.Fatal(err)
			}
		},
	}

	cmd.PersistentFlags().StringVar(&reqArgs.L0.L1.L2.L3, "l0-l1-l2-l3", "", "get-comment-from-proto")

	return cmd
}

func init() {
	cmd := _NestedMessagesGetDeeplyNestedClientCommand()
	NestedMessagesClientCommand.AddCommand(cmd)
	_DefaultNestedMessagesClientCommandConfig.AddFlags(cmd.Flags())
}
